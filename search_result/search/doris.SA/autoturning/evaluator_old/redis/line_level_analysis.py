import json
import os
import subprocess
from functools import cache


def convert_json_to_dict(data):
    functions = {}
    
    for entry in data:        
        key = (entry["file_path"], entry["func_name"].split("::")[-1])
        range_key = (entry["begin_line"], entry["end_line"])
        
        if key not in functions:
            functions[key] = {}
        
        if range_key not in functions[key]:
            functions[key][range_key] = {
                "store_class": entry["store_class"],
                "return_type": entry["return_type"],
                "param_number": entry["param_number"],
                "param_names": entry["param_names"],
                "param_types": entry["param_types"]
            }
    return functions

# The `function_dict` stores information about all functions, including their file path, 
# function name, starting line, ending line, storage class, return type, number of parameters, 
# parameter names, and parameter types. This information helps identify the starting line 
# number of each function.
@cache
def load_functions(base_path:str)->dict:
    """
    Load function information from the project-func-info-database.json file.
    The project-func-info-database.json file records the file path, function name, 
    starting line number, ending line number, and other information for all functions 
    in the project. This information is used to assist in analyzing the performance 
    report generated by gperftools.

    :param base_path: The base path of the project, which is used to locate the project-func-info-database.json file.

    :return: A dictionary that stores information about all functions in the project. 
             The dictionary is two-dimensional: the first key is a tuple of the file 
             path and function name, and the second key is a tuple of the starting 
             and ending line numbers. The value is a dictionary containing other 
             information about the function, such as storage class, return type, 
             number of parameters, parameter names, and parameter types.
    """
    function_infos = {}
    function_file = os.path.join(base_path, "project-func-info-databaase.json")
    os.system(f'cp project-func-info-databaase.json {function_file}')
    function_info = []
    with open(function_file, "r") as f:
        for line in f:
            function_info.append(json.loads(line))
        function_infos = convert_json_to_dict(function_info)
    return function_infos

class LineAnalysis:
    def __init__(self, base_path:str, program_name:str, report_file:str="report.txt"):
        """
        Initialize the LineAnalysis object.

        :param base_path: The base path of the project, which is used to locate the report file/project-func-info-database.json file.
        :param program_name: The name of the program.
        :param report_file: The name of the report file. The default value is "report.txt".
        """
        self.base_path = base_path 
        self.report_file = os.path.join(base_path, report_file)
        self.program_name = program_name
        self.function_dict = load_functions(self.base_path)
        
    
    def get_range(self, file_path:str, func_name:int, line_number:int):
        """
        Get the range of the function based on the file path, function name, and line number.

        :param file_path: The file path of the function.
        :param func_name: The name of the function.
        :param line_number: The line number of the function.

        :return: A tuple containing the beginning and ending line numbers of the function.
        """
        function_dict = self.function_dict 
        if (file_path, func_name) in function_dict:
            func_data = function_dict[(file_path, func_name)] 
            for (begin_line, end_line) in func_data:
                if begin_line <= line_number <= end_line:
                    return begin_line, end_line
        return None, None
    
    
    def parse_report_line(self, line):
        """
        Parse a line of the report file and return the key and value.

        :param line: A line of the report file.

        :return: A tuple containing the key and value of the parsed line. The key is a tuple
                 containing the file path, function name, beginning line number, and ending
                 line number. The value is a tuple containing the self time and total time.
        """
        parsed = line.strip().replace("(inline)", "").split()
    
        if len(parsed) != 7:
            return None, None
        
        if parsed[-1].split(":")[0] == "??":
            return None, None
        
        file_path = parsed[-1].split(":")[0]
        line_number = int(parsed[-1].split(":")[1])
        func_name = parsed[-2].split("::")[-1].split("@")[0]
        self_time = int(parsed[0])
        total_time = int(parsed[3])
        
        begin_line, end_line = self.get_range(file_path, func_name, line_number)
        
        if not begin_line:
            return None, None
        key = (file_path, func_name, begin_line, end_line)
        val = [self_time, total_time]
        return key, val
        

    def parse_report(self):
        """
        Parse the report file and return the results.

        :return: A tuple containing the keys and values of the parsed report file. The keys
                    are tuples containing the file path, function name, beginning line number, 
                    and ending line number. The values are tuples containing the self time and 
                    total time.
        """
        results = {}
        repeat = 0
        print(self.report_file)
        if not os.path.exists(self.report_file):
            print(f"Report file {self.report_file} does not exist.")
            return None
        with open(self.report_file, 'r') as file:
            for line in file:
                if line.startswith('Total'):
                    repeat += 1
                    # key, val = ('Total', "None", 0, 0), (int(line.split()[1]), int(line.split()[1]))
                else:
                    key, val = self.parse_report_line(line)
                    if not (key or val):
                        continue
                    if key in results:
                        results[key] = list(a + b for a, b in zip(results[key], val))
                    else:
                        results[key] = val
                    
        if repeat > 0:
            return results
        return results
    
    
    def parse_address(self, address):
        """
        Use addr2line to parse the address and return the file name and line number.

        :param address: The address to be parsed.

        :return: A tuple containing the file name and line number of the parsed address.
        """
        try:
            result = subprocess.run(['addr2line', '-e', self.program_name, address], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            output = result.stdout.decode('utf-8').strip()
            if output:
                file_line = output.split(':')
                if file_line[0].startswith(self.base_path):
                    return file_line[0], file_line[1]
        except Exception as e:
            print(f"Error parsing address {address}: {e}")
        return None, None


def main():
    base_path = '/home/whq/SRTuner/SRTuner/demo/gcc/cBench/network_dijkstra/src'
    analysis = LineAnalysis(base_path, "program_name")
    results = analysis.parse_report()
    analysis.print_report(results)


if __name__ == "__main__":
    main()